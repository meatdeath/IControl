//---------------------------------------------------------------------------

#include <vcl.h>
#pragma hdrstop

#include "main.h"
#include "options.h"
#include "string.h"
#include <systdate.h>
#include <DateUtils.Hpp>
#include <Registry.hpp>
#include <dir.h>
//---------------------------------------------------------------------------
#pragma package(smart_init)
#pragma resource "*.dfm"
TMainForm *MainForm;

UnicodeString APP_NAME = L"RTEC - Регистратор тока";

UnicodeString Com = "";
int Baudrate = 0;
bool AxisLog;
double AxisLogBase;
bool dataSaved = true;

//---------------------------------------------------------------------------
__fastcall TMainForm::TMainForm(TComponent* Owner)
	: TForm(Owner)
{
}
//---------------------------------------------------------------------------
void __fastcall TMainForm::ExitActionExecute(TObject *Sender)
{
	DataClearAllBlocks();
	Close();
}
//---------------------------------------------------------------------------
int data_count = 0;

//---------------------------------------------------------------------------
#define DATA_SIZE	750
#define SEC_IN_DAY	(24.0*60*60)

#define MSEC_IN_DAY	(24.0*60*60*1000)
#define MEASURE_PERIOD_MS	150
enum {
	STATE_IDLE = 0,
	STATE_CONNECTING,
	STATE_CONNECTED,
	STATE_DISCONNECTING,
	STATE_DISCONNECTED
};

//---------------------------------------------------------------------------
DATA_BLOCK *data_head = NULL;
DATA_BLOCK *data_tail = NULL;
int state = STATE_IDLE;
//---------------------------------------------------------------------------

void DataBlockAdd( TDateTime time, const void *data, WORD len )
{
	DATA_BLOCK *new_data_block = new DATA_BLOCK;
	new_data_block->time = time;
	new_data_block->next = NULL;
	new_data_block->current_arr = new BYTE(len);
	int offset = 0;


	if( data_tail == NULL ) {
		for (offset = 0; offset < len; offset++) {
			 if( ((unsigned char *)data)[offset] <= 0x03 )  break;
			 len--;
		}
	}
	memcpy( new_data_block->current_arr, &((unsigned char *)data)[offset], len );
	new_data_block->current_arr_len = len;

	if( data_tail == NULL )
	{
		data_head = new_data_block;
		data_tail = new_data_block;
	}
	else
	{
		data_tail->next = new_data_block;
		data_tail = data_tail->next;
	}
}

//---------------------------------------------------------------------------

DATA_BLOCK* GetLastDataBlockPtr() {
	return data_tail;
}

//---------------------------------------------------------------------------

void DataClearAllBlocks()
{
	while( data_head != NULL )
	{
		DATA_BLOCK *next = data_head->next;
		delete data_head->current_arr;
		delete data_head;
		data_head = next;
	}
	data_tail = NULL;
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::GenerateData()
{
	WORD data[DATA_SIZE] = {0};
	WORD data2[DATA_SIZE] = {0};
	TDateTime time1, time2;
	TDateTime tick = (1.0*MEASURE_PERIOD_MS) / MSEC_IN_DAY;
	TDateTime delay = (750.0*MEASURE_PERIOD_MS) / MSEC_IN_DAY;
	time2 = Now();
	time1 = time2 - delay;
	WORD gen_value = 1000;
	WORD gen_value2 = 130;

	randomize();
	for( int i = 0; i < DATA_SIZE; i++ )
	{
		int step = rand()%100 - 50;
		if( (gen_value < 800 && step < 0) || (gen_value > 1300 && step > 0) )
		{
			step = -step;
		}
		gen_value = gen_value + step;
		data[i] = gen_value;

		step = rand()%10 - 5;
		if( (gen_value2 < 100 && step < 0) || (gen_value2 > 180 && step > 0) )
		{
			step = -step;
		}
		gen_value2 = gen_value2 + step;
		data2[i] = gen_value2;
	}

	int i;
	TColor color;
	TDateTime time;
	UnicodeString time_str;
	double value, value2;

	for( i = 0; i < DATA_SIZE; i++, data_count++ )
	{
		color = clGreen;
		//value = data_tail->current_arr[i];
		value = data[i];
		//value2 = data2[i];
		if( value >= 1000 ) color = clRed;
		tick = ((double)i*MEASURE_PERIOD_MS) / (MSEC_IN_DAY);
		time = time1 + tick;
		time_str = time.FormatString("hh:nn:ss.zzz");
		// time_str = time.TimeString();
		CurrentSeries->AddXY( data_count, value, time_str, color );
	}

	ScrollBar->Max = data_count;
	UpdateScroll();

	DataBlockAdd( time1, data, data_count );
}
//---------------------------------------------------------------------------
void __fastcall TMainForm::UpdateActionState(int new_state)
{
	state = new_state;
	if( data_head != NULL )
	{
		MagnifyPlusAction->Enabled = true;
		MagnifyMinusAction->Enabled = true;
	}
	else
	{
		MagnifyPlusAction->Enabled = false;
		MagnifyMinusAction->Enabled = false;
    }
	switch( state )
	{
		case STATE_IDLE:
			if( data_head == NULL )
			{
				SaveAction->Enabled = false;
			}
			else
			{
				SaveAction->Enabled = true;
			}
			NewAction->Enabled = true;
			OpenAction->Enabled = true;
			OptionsAction->Enabled = true;
			ConnectAction->Enabled = true;
			DisconnectAction->Enabled = false;
			break;

		case STATE_CONNECTING:
			DataClearAllBlocks();

		case STATE_DISCONNECTING:
			SaveAction->Enabled = false;
			NewAction->Enabled = false;
			OpenAction->Enabled = false;
			OptionsAction->Enabled = false;
			ConnectAction->Enabled = false;
			DisconnectAction->Enabled = false;
			break;

		case STATE_CONNECTED:
			DisconnectAction->Enabled = true;
			ConnectAction->Enabled = false;
			SaveAction->Enabled = false;
			OpenAction->Enabled = false;
			break;
    }
}
//---------------------------------------------------------------------------
int scroll_bar_page_size = 200;
void __fastcall TMainForm::UpdateScroll()
{
	ScrollBar->Min = 0;
	//ScrollBar->Position = 0;
	if(!data_count) return;
	ScrollBar->Max = data_count;
	ScrollBar->PageSize = scroll_bar_page_size;
	//ScrollBar->Position = ScrollBar->Max - ScrollBar->PageSize;
	ScrollBar->LargeChange = scroll_bar_page_size;
}
//---------------------------------------------------------------------------
void __fastcall TMainForm::ConnectActionExecute(TObject *Sender)
{
	if( !dataSaved ) {
		if( Application->MessageBox( L"Данные не сохранены. Все равно продолжить и потерять раннее сохраненные данные?", L"Внимание", MB_ICONWARNING|MB_YESNO ) == IDNO )
			return;
	}
	CurrentSeries->Clear();
	data_count = 0;
	UpdateActionState( STATE_CONNECTING );
	Timer->Interval = 10;
	//GenerateData();
	Timer->Enabled = true;

	TComThread *thrd = new TComThread();
	thrd->OnTerminate = &ThreadTerminated;
	thrd->Start();
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::ChartZoom(TObject *Sender)
{
	Application->ProcessMessages();
	scroll_bar_page_size = Chart->BottomAxis->Maximum - Chart->BottomAxis->Minimum;
	UpdateScroll();
	ScrollBar->Position = Chart->BottomAxis->Minimum;
//	Chart->BottomAxis->Minimum = ScrollBar->Position;
//	Chart->BottomAxis->Maximum = ScrollBar->Position + ScrollBar->PageSize;
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::DisconnectActionExecute(TObject *Sender)
{
	Timer->Interval = 10;
	UpdateActionState( STATE_DISCONNECTING );
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::ChartUndoZoom(TObject *Sender)
{
	Application->ProcessMessages();
	scroll_bar_page_size = 200;
	UpdateScroll();
//	int pos = ScrollBar->Position - (200 - (Chart->BottomAxis->Maximum - Chart->BottomAxis->Minimum)) / 2;
//	if ( (pos+scroll_bar_page_size) > data_count) {
//		pos = data_count - scroll_bar_page_size;
//	}
//	if (pos < 0) pos = 0;
//	ScrollBar->Position = pos;
	ScrollBar->Position = Chart->BottomAxis->Minimum;
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::FormResize(TObject *Sender)
{
	Chart->BottomAxis->Maximum = Chart->BottomAxis->Minimum + (Chart->Width-108)/10;
	UpdateScroll();
}
//---------------------------------------------------------------------------

#define PORT_FIFO_SIZE 200
#define PACK_BUF_SIZE 10000
HANDLE hPort = NULL;
DCB dcb;
BYTE buf[PORT_FIFO_SIZE] = {0};
BYTE buf_index = 0;
BYTE pack[PACK_BUF_SIZE] = {0};
int pack_length = 0;

bool show_value_assebled = true;
WORD show_value;

#define READ_BUF_SIZE  PORT_FIFO_SIZE


void __fastcall TMainForm::TimerTimer(TObject *Sender)
{
	bool fSuccess;
	Timer->Interval = 100;

	Timer->Enabled = false;
	switch( state )
	{
	case STATE_CONNECTING:
//		hPort = CreateFile(
//			("\\\\.\\"+Com).c_str(),     // address of name of the communications device
//			GENERIC_READ | GENERIC_WRITE,          // access (read-write) mode
//			0,                  // share mode
//			NULL,               // address of security descriptor
//			OPEN_EXISTING,      // how to create
//			0,                  // file attributes
//			NULL                // handle of file with attributes to copy
//		);
//		if( hPort == INVALID_HANDLE_VALUE )
//		{
//			Application->MessageBox( (L"Невозможно открыть порт "+ Com +L". Порт занят или не существует.").c_str(), L"Ошибка", MB_ICONERROR|MB_OK );
//			UpdateActionState( STATE_IDLE );
//			Timer->Enabled = false;
//		}
//		else
//		{
//			//LPCOMMTIMEOUTS com_timeouts = {
//			COMMTIMEOUTS com_timeouts = {
//				/*.ReadIntervalTimeout =*/ 100,
//				/*.ReadTotalTimeoutMultiplier =*/ 100,
//				/*.ReadTotalTimeoutConstant =*/ 100,
//				/*.WriteTotalTimeoutMultiplier =*/ 100,
//				/*.WriteTotalTimeoutConstant =*/ 100
//			};
//			fSuccess = SetCommTimeouts( hPort, &com_timeouts );
//
//			//  Initialize the DCB structure.
//			SecureZeroMemory(&dcb, sizeof(DCB));
//			dcb.DCBlength = sizeof(DCB);
//
//			//  Build on the current configuration by first retrieving all current
//			//  settings.
//			fSuccess = GetCommState(hPort, &dcb);
//
//			//  Fill in some DCB values and set the com state:
//			//  Baudrate, 8 data bits, no parity, and 1 stop bit.
//			dcb.BaudRate = Baudrate;      //  baud rate
//			dcb.ByteSize = 8;             //  data size, xmit and rcv
//			dcb.Parity   = NOPARITY;      //  parity bit
//			dcb.StopBits = ONESTOPBIT;    //  stop bit
//
//			fSuccess = SetCommState(hPort, &dcb);

			UpdateActionState( STATE_CONNECTED );

			Timer->Interval = 1;
//		}
		show_value_assebled = true;
		break;

	case STATE_DISCONNECTING:
		break;

	case STATE_DISCONNECTED:
		Timer->Enabled = false;
//		CloseHandle( hPort );
		UpdateActionState( STATE_IDLE );

		data_count = 0;

		if( data_head != NULL ) {

			DATA_BLOCK *data_ptr = data_head;
			TColor color;
			UnicodeString time_str;
			double value;
			TDateTime time2 = data_ptr->time;
			TDateTime time1 = time2 - (double)(20*(data_ptr->current_arr_len+((show_value_assebled)?1:0)/2-1));
			//double tick = 0.020;
			do {
				for( int i = 0; i < data_ptr->current_arr_len; i++ ) {
					show_value_assebled = !show_value_assebled;

					if( show_value_assebled )
					{
						show_value |= data_ptr->current_arr[i];
						color = clGreen;
						value = (double)show_value;
						if( value >= 1000 ) color = clRed;
						time_str = time1.FormatString("hh:nn:ss.zzz");
						CurrentSeries->AddXY( data_count++, value, time_str, color );
						//time1 = time1 + tick;
						time1 += 0.001;
						dataSaved = false;
//						str.sprintf(L"%02X %02X : ",buf[i], buf[i+1]);
//						line+=str;
					}  else {
						show_value = data_ptr->current_arr[i];
						show_value <<= 8;
                    }
				}
				data_ptr = data_ptr->next;
			}
			while( data_ptr );
			UpdateScroll();
			ScrollBar->Position = ScrollBar->Max - ScrollBar->PageSize;
		}

		break;

	case STATE_CONNECTED:
		{
			DWORD /*bytes_to_read = 1,*/ bytes_read = 0;
			UnicodeString line = "";
			//bool data_ready = false;

//			do
//			{
//				fSuccess = ReadFile( hPort, buf, (PORT_FIFO_SIZE/8), &bytes_read, NULL );
//				if( bytes_read )
//					DataBlockAdd( Now(), buf, bytes_read );
//				Application->ProcessMessages();
//			}
//			while( bytes_read && state == STATE_CONNECTED);



//			while( bytes_read == PORT_FIFO_SIZE ) {
//				fSuccess = ReadFile( hPort, buf, bytes_to_read, &bytes_read, NULL );
//				if( !fSuccess )
//				{
//					Memo1->Lines->Add("--------------- ERROR DETECTED --------------" );
//					break;
//				}
//
//				if (bytes_read) {
////					if (bytes_read&1) {
////						DWORD bytes_read2 = 0;
////
////						fSuccess = ReadFile( hPort, buf+bytes_read, 1, &bytes_read2, NULL );
////						bytes_read += bytes_read2;
////					}
//					TDateTime time1, time2;
//					TDateTime tick = 20;
//					time2 = Now();
//					time1 = time2 - (double)(20*(bytes_read/2-1));
//					DWORD i;
//					TColor color;
//					UnicodeString time_str;
//					double value;
//
//					UnicodeString str;
//
//					for( i = 0; i < bytes_read; i+=2, data_count++ )
//					{
//						color = clGreen;
//						//value = data_tail->current_arr[i];
//						value = (double)((((WORD)buf[i+1])<<8) + buf[i]);
//						if( value >= 1000 ) color = clRed;
//						time_str = time1.FormatString("hh:nn:ss.zzz");
//						// time_str = time.TimeString();
//						CurrentSeries->AddXY( data_count, value, time_str, color );
//						time1 = time1 + tick;
//						dataSaved = false;
//						str.sprintf(L"%02X %02X : ",buf[i], buf[i+1]);
//						line+=str;
//					}
//					Timer->Interval = 1;
//
//					//ScrollBar->Max = data_count;
//
//				//DataBlockAdd( time1, buf,  );
//				}
//			}
//			if( data_count > 100 )
//				ScrollBar->Max = data_count;
//			UpdateScroll();
//			Memo1->Lines->Add(line);

			break;
		}
	}

	Timer->Enabled = true;
}
//---------------------------------------------------------------------------
void __fastcall TMainForm::ScrollBarChange(TObject *Sender)
{
	if( ScrollBar->Position > (ScrollBar->Max-ScrollBar->PageSize) )
	{
		ScrollBar->Position = ScrollBar->Max - ScrollBar->PageSize;
	}

	if( ScrollBar->Position > Chart->BottomAxis->Minimum )
	{
		Chart->BottomAxis->Maximum = ScrollBar->Position + ScrollBar->PageSize;
		Chart->BottomAxis->Minimum = ScrollBar->Position;
	}
	else
	{
		Chart->BottomAxis->Minimum = ScrollBar->Position;
		Chart->BottomAxis->Maximum = ScrollBar->Position + ScrollBar->PageSize;
	}
}
//---------------------------------------------------------------------------

// Example got from
// https://stackoverflow.com/questions/11639859/threads-in-c-builder
//
// For methods and properties go to page
// http://docs.embarcadero.com/products/rad_studio/delphiAndcpp2009/HelpUpdate2/EN/html/delphivclwin32/!!MEMBEROVERVIEW_Classes_TThread.html

__fastcall TComThread::TComThread()
    : TThread(true)
{
    FreeOnTerminate = true;
    // setup other thread parameters as needed...
}

void ReportStatusEvent( DWORD event ) {

}

void DoBackgroundWork(void) {
	Sleep(10);
}

#define READ_TIMEOUT_MSEC 100

BOOL ReadComPort(HANDLE hComm, char * lpBuf, DWORD &dwRead) {

    BOOL fRes = FALSE;
    OVERLAPPED osReader = { 0 };

    // Create the overlapped event. Must be closed before exiting
    // to avoid a handle leak.
    osReader.hEvent = ::CreateEvent(NULL, TRUE, FALSE, NULL);

    if (osReader.hEvent == NULL) {

        // error creating overlapped event handle
        return FALSE;
    }

    // Issue read operation.
    DWORD fSuccess = ::ReadFile(hComm, lpBuf, READ_BUF_SIZE, &dwRead, &osReader);

    DWORD dwErr = GetLastError();

    if (!fSuccess) {

        //if (::GetLastError() != ERROR_IO_PENDING) {
        if (false) {

            // WriteFile failed, but isn't delayed. Report error and abort.
			fRes = FALSE;
        }
        else {

			DWORD dwRes = ::WaitForSingleObject(osReader.hEvent, READ_TIMEOUT_MSEC);

            switch (dwRes) {

                // Read completed.
                case WAIT_OBJECT_0:

                    if (!::GetOverlappedResult(hComm, &osReader, &dwRead, FALSE)) {

                        // Error in communications; report it.
						//throw new exception("Error in communications");
						;
                    }
                    else {

                        // Read completed successfully.
                        fRes = TRUE;
                    }

                    break;

                case WAIT_TIMEOUT:

                    // Operation isn't complete yet. fWaitingOnRead flag isn't
                    // changed since I'll loop back around, and I don't want
                    // to issue another read until the first one finishes.
                    //
                    // This is a good time to do some background work.
                    fRes = FALSE;
                    break;

                default:
                    // Error in the WaitForSingleObject; abort.
                    // This indicates a problem with the OVERLAPPED structure's
                    // event handle.
                    fRes = FALSE;
                    break;
            }

        }

    }

	if (osReader.hEvent != NULL) ::CloseHandle(osReader.hEvent);
	return fRes;
}

void __fastcall TComThread::Execute()
{

// COM read example from
// https://docs.microsoft.com/en-us/previous-versions/ff802693(v=msdn.10)

	LPCTSTR gszPort = ("\\\\.\\"+Com).c_str();

	HANDLE hComm = NULL;

	try {

		hComm = ::CreateFile( gszPort,
            GENERIC_READ | GENERIC_WRITE,
            0,
            NULL,
            OPEN_EXISTING,
            FILE_FLAG_OVERLAPPED,
            NULL);

        if ( hComm == INVALID_HANDLE_VALUE ) {

			//throw new exception("INVALID_HANDLE_VALUE");
        }

        DCB dcb;

        ::FillMemory(&dcb, sizeof(dcb), 0);

        DWORD fSuccess = ::GetCommState(hComm, &dcb);

        if (!fSuccess){

			//throw new exception("GetCommState()");
        }

        dcb.DCBlength = sizeof(DCB);
        dcb.BaudRate = Baudrate;
        dcb.Parity = NOPARITY;
        dcb.fBinary = TRUE;
        dcb.ByteSize = 8;
        dcb.StopBits = ONESTOPBIT;
        dcb.fDtrControl = DTR_CONTROL_DISABLE;
        dcb.fRtsControl = RTS_CONTROL_DISABLE;

        fSuccess = ::SetCommState(hComm, &dcb);

        if (!fSuccess){

			//throw new exception("SetCommState()");
        }

        // Contains various COM timeouts
        COMMTIMEOUTS CommTimeouts;

        // Timeouts in msec.
        CommTimeouts.ReadIntervalTimeout = MAXDWORD;
        CommTimeouts.ReadTotalTimeoutMultiplier = 0;
        CommTimeouts.ReadTotalTimeoutConstant = 0;
        CommTimeouts.WriteTotalTimeoutMultiplier = 0;
        CommTimeouts.WriteTotalTimeoutConstant = 0;

        // Set COM timeouts.
        fSuccess = ::SetCommTimeouts(hComm, &CommTimeouts);

        if (!fSuccess){

			//throw new exception("SetCommTimeouts()");
        }


        // Принимаем ответ.
        char * buff;
		DWORD dwRead;
		while( state == STATE_CONNECTING || state == STATE_CONNECTED ) {
			ReadComPort(hComm, buf, dwRead);
			if( dwRead )
				DataBlockAdd( Now(), buf, dwRead );
				//HandleASuccessfulRead(buf, dwRead);
		}

    }
	//catch ( exception &ex ) {
	catch ( ... ) {

		//cout << "[ERROR] " << ex.what() << endl;
	}

    if (hComm != NULL )    ::CloseHandle( hComm );

//	HANDLE hComm;
//	hComm = CreateFile( gszPort,
//						GENERIC_READ | GENERIC_WRITE,
//						0,
//						0,
//						OPEN_EXISTING,
//						FILE_FLAG_OVERLAPPED,
//						0);
//
//	if (hComm != INVALID_HANDLE_VALUE)  {
//
//		#define STATUS_CHECK_TIMEOUT      500   // Milliseconds
//
//		//-----------------------
//
//		COMSTAT comStat;
//		DWORD   dwErrors;
//		BOOL    fOOP, fOVERRUN, fPTO, fRXOVER, fRXPARITY, fTXFULL;
//		BOOL    fBREAK, fDNS, fFRAME, fIOE, fMODE;
//		// Get and clear current errors on the port.
//		if (!ClearCommError(hComm, &dwErrors, &comStat))
//			// Report error in ClearCommError.
//			return;
//
//		//-------------------------
//
//		DCB dcb;
//
//		FillMemory(&dcb, sizeof(dcb), 0);
//		if (!GetCommState(hComm, &dcb))     // get current DCB
//		  // Error in GetCommState
//		  return;
//
//		// Update DCB rate.
//		dcb.BaudRate = CBR_115200 ;
//
//		// Set new state.
//		if (!SetCommState(hComm, &dcb))
//		  // Error in SetCommState. Possibly a problem with the communications
//		  // port handle or a problem with the DCB structure itself.
//		  return;
//
//		//-------------------------
//
//		COMMTIMEOUTS timeouts;
//
//		timeouts.ReadIntervalTimeout = 20;
//		timeouts.ReadTotalTimeoutMultiplier = 10;
//		timeouts.ReadTotalTimeoutConstant = 100;
//		timeouts.WriteTotalTimeoutMultiplier = 10;
//		timeouts.WriteTotalTimeoutConstant = 100;
//
//		if (!SetCommTimeouts(hComm, &timeouts))
//		   // Error setting time-outs.
//		   return;
//
//		//-------------------------
//
//
//		DWORD      dwRes;
//		DWORD      dwCommEvent;
//		DWORD      dwStoredFlags;
//		DWORD	   dwOvRes;
//		BOOL      fWaitingOnStat = FALSE;
//		OVERLAPPED osStatus = {0};
//
//		dwStoredFlags = EV_BREAK | EV_CTS | EV_DSR | EV_ERR | EV_RING |\
//					  EV_RLSD | EV_RXCHAR | EV_RXFLAG | EV_TXEMPTY ;
//		if (!SetCommMask(hComm/*comHandle*/, dwStoredFlags)) {
//			// error setting communications mask; abort
//			return;
//		}
//
//		osStatus.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
//		if (osStatus.hEvent == NULL) {
//			// error creating event; abort
//			return;
//		}
//
//		//-------------------------
//
//		for ( ; ; ) {
//			if (!fWaitingOnStat) {
//			   // Issue read operation.
//			   if (!ReadFile(hComm, buf, READ_BUF_SIZE, &dwRead, &osReader)) {
//				  if (GetLastError() != ERROR_IO_PENDING)     // read not delayed?
//					 // Error in communications; report it.
//				  else
//					 fWaitingOnStat = TRUE;
//			   }
//			   else {
//				  // read completed immediately
//				  HandleASuccessfulRead(lpBuf, dwRead);
//				}
//			}
//			// Issue a status event check if one hasn't been issued already.
//			if (!fWaitingOnStat) {
//				if (!WaitCommEvent(hComm, &dwCommEvent, &osStatus)) {
//					if (GetLastError() == ERROR_IO_PENDING)
//					   //bWaitingOnStatusHandle = TRUE;
//					   ;
//					else
//					   // error in WaitCommEvent; abort
//					   break;
//				}
//				else
//					// WaitCommEvent returned immediately.
//					// Deal with status event as appropriate.
//					ReportStatusEvent(dwCommEvent);
//			}
//
//			// Check on overlapped operation.
//			if (fWaitingOnStat) {
//				// Wait a little while for an event to occur.
//				dwRes = WaitForSingleObject(osStatus.hEvent, STATUS_CHECK_TIMEOUT);
//				switch(dwRes)
//				{
//				 // Event occurred.
//				 case WAIT_OBJECT_0:
//					 if (!GetOverlappedResult(hComm, &osStatus, &dwOvRes, FALSE))
//						// An error occurred in the overlapped operation;
//						// call GetLastError to find out what it was
//						// and abort if it is fatal.
//						;
//					 else
//						// Status event is stored in the event flag
//						// specified in the original WaitCommEvent call.
//						// Deal with the status event as appropriate.
//						ReportStatusEvent(dwCommEvent);
//
//					 // Set fWaitingOnStat flag to indicate that a new
//					 // WaitCommEvent is to be issued.
//					 fWaitingOnStat = FALSE;
//					 break;
//
//				 case WAIT_TIMEOUT:
//					 // Operation isn't complete yet. fWaitingOnStatusHandle flag
//					 // isn't changed since I'll loop back around and I don't want
//					 // to issue another WaitCommEvent until the first one finishes.
//					 //
//					 // This is a good time to do some background work.
//					DoBackgroundWork();
//					 break;
//
//				 default:
//					 // Error in the WaitForSingleObject; abort
//					 // This indicates a problem with the OVERLAPPED structure's
//					 // event handle.
//					CloseHandle(osStatus.hEvent);
//					return;
//				}
//			}
//		}
//
//		CloseHandle(osStatus.hEvent);
//
//	} else {
//		// error opening port; abort
//	}
//
//	// if you need to access the UI controls,
//	// use the TThread::Synchornize() method for that
}

void __fastcall TMainForm::ThreadTerminated(TObject *Sender)
{
	// thread is finished with its work ...
	UpdateActionState(STATE_DISCONNECTED);
}



//---------------------------------------------------------------------------

void __fastcall TMainForm::FormShow(TObject *Sender)
{

	UpdateComBox();

	AnsiString com;
	long baudrate;
    int i;
	TRegistry *Reg = new TRegistry;
	Reg->RootKey = HKEY_CURRENT_USER;
	Reg->Access = KEY_ALL_ACCESS;
	if( Reg->OpenKey("\\Software\\RTEC\\CurrentControl\\", true) )
	{
		try
		{
			MainForm->Left   = Reg->ReadInteger( "WindowLeft" );
			MainForm->Top    = Reg->ReadInteger( "WindowTop" );
			MainForm->Width  = Reg->ReadInteger( "WindowWidth" );
            MainForm->Height = Reg->ReadInteger( "WindowHeight" );
        }
		catch(...)
		{
			//MessageBox( NULL, (wchar_t*)"Error occured while reading window position from registry!", (wchar_t*)"Error", MB_OK|MB_ICONERROR );
		}

        try
		{
            com = Reg->ReadString( "Port" );
        }
		catch(...)
        {
//MessageBox(NULL,"Step 13","Debug start", MB_ICONINFORMATION|MB_OK );
            com = "COM1";
        }
        for( i = 0; i < OptionsForm->PortBox->Items->Count; i++ )
        {
			if( com == OptionsForm->PortBox->Items->Strings[i] )
                break;
        }
        if( i == OptionsForm->PortBox->Items->Count )
        {
            Com = OptionsForm->PortBox->Items->Strings[0];
            OptionsForm->PortBox->ItemIndex = 0;
        }
        else
        {
            OptionsForm->PortBox->ItemIndex = i;
            Com = com;
        }


        try
        {
//MessageBox(NULL,"Step 14","Debug start", MB_ICONINFORMATION|MB_OK );
            baudrate = Reg->ReadInteger( "Baudrate" );
        }
		catch(...)
        {
//MessageBox(NULL,"Step 15","Debug start", MB_ICONINFORMATION|MB_OK );
			baudrate = 115200;
        }
        for( i = 0; i < OptionsForm->BaudrateBox->Items->Count; i++ )
        {
			if( baudrate == StrToInt((__int64)(OptionsForm->BaudrateBox->Items->Strings[i].ToIntDef(115200))) )
                break;
        }
        if( i == OptionsForm->BaudrateBox->Items->Count )
        {
            OptionsForm->BaudrateBox->ItemIndex = 6;
        }
        else
        {
            OptionsForm->BaudrateBox->ItemIndex = i;
        }
        Baudrate = StrToInt( OptionsForm->BaudrateBox->Items->Strings[OptionsForm->BaudrateBox->ItemIndex] );

        Reg->CloseKey();
//MessageBox(NULL,"Step 16","Debug start", MB_ICONINFORMATION|MB_OK );
    }
    else
    {
//MessageBox(NULL,"Step 17","Debug start", MB_ICONINFORMATION|MB_OK );
        OptionsForm->PortBox->ItemIndex = 0;
        //Com = OptionsForm->PortBox->Items->Strings[OptionsForm->PortBox->ItemIndex];
        Com = OptionsForm->PortBox->Text;
        OptionsForm->BaudrateBox->ItemIndex = 6;
        Baudrate = StrToInt( OptionsForm->BaudrateBox->Items->Strings[OptionsForm->BaudrateBox->ItemIndex] );
	}

	delete Reg;

	MainForm->Caption = APP_NAME + " - " + Com;
	Application->Title = APP_NAME + " - " + Com;

	UpdateActionState(STATE_IDLE);
}
//--------------------------------
void __fastcall TMainForm::RegistryWriteSettings()
{
	TRegistry *Reg = new TRegistry;
	Reg->RootKey = HKEY_CURRENT_USER;
	Reg->Access = KEY_ALL_ACCESS;
	if( Reg->OpenKey("\\Software\\RTEC\\CurrentControl\\", true) )
	{
		Reg->WriteString( "Port", Com );
		Reg->WriteInteger( "Baudrate", Baudrate );
		Reg->WriteInteger( "AxisLog", 		AxisLog );
		Reg->WriteInteger( "AxisLogBase", 	AxisLogBase );
		Reg->WriteInteger( "WindowLeft",    MainForm->Left );
		Reg->WriteInteger( "WindowTop",     MainForm->Top );
		Reg->WriteInteger( "WindowWidth",   MainForm->Width );
		Reg->WriteInteger( "WindowHeight",  MainForm->Height );
		Reg->CloseKey();
	}
	delete Reg;
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::FormClose(TObject *Sender, TCloseAction &Action)
{
	DataClearAllBlocks();
	RegistryWriteSettings();
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::OpenActionExecute(TObject *Sender)
{
	int iFileHandle;
	int iFileLength;
	int iBytesRead;

	int i, ii;
	TColor color;
	TDateTime time;
	double value;
	TDateTime tick;

	CurrentSeries->Clear();
	data_count = 0;

	if (OpenDialog->Execute())
	{
		try
		{
			iFileHandle = FileOpen(OpenDialog->FileName, fmOpenRead);
			iFileLength = FileSeek(iFileHandle,0,2);

			if( (iFileLength%sizeof(DATA_BLOCK)) == 0 )
			{
				FileSeek(iFileHandle,0,0);
				for( i = 0; i < iFileLength; i += iBytesRead )
				{
					DATA_BLOCK *tmp = new DATA_BLOCK;
					iBytesRead = FileRead( iFileHandle, tmp, sizeof(DATA_BLOCK) );
					if( data_head == NULL ) {
						data_tail = data_head = tmp;
					}
					else
					{
						data_tail->next = tmp;
						data_tail = tmp;
					}
					data_tail->next = NULL;


					for( ii = 0; ii < DATA_SIZE; ii++, data_count++ )
					{
						TDateTime time;
						UnicodeString time_str;
						color = clGreen;
						//value = data_tail->current_arr[i];
						value = data_tail->current_arr[ii];
						if( value >= 1000 ) color = clRed;
						tick = ((double)ii*MEASURE_PERIOD_MS) / (MSEC_IN_DAY);
						time = data_tail->time + tick;
						time_str = time.TimeString();
						CurrentSeries->AddXY( data_count, value, time_str, color );
						//CurrentSeries->AddXY( (double)100, (double)10, "", clGreen );
					}

					ScrollBar->Max = data_count;
					UpdateScroll();
					UpdateActionState( STATE_IDLE );
				}
			}
			else
			{
				Application->MessageBox(((UnicodeString)"Can't read file! Data corrupted.").c_str(), ((UnicodeString)"File Error").c_str(), IDOK);
			}
			FileClose(iFileHandle);
		}
		catch(...)
		{
			Application->MessageBox(((UnicodeString)"Can't perform one of the following file operations: Open, Seek, Read, Close.").c_str(), ((UnicodeString)"File Error").c_str(), IDOK);
		}
	}
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::SaveActionExecute(TObject *Sender)
{
	char szFileName[MAXFILE+4];
	int iFileHandle;
	int iLength;
	if (SaveDialog->Execute())
	{
		if (FileExists(SaveDialog->FileName))
		{
			fnsplit(((AnsiString)(SaveDialog->FileName)).c_str(), 0, 0, szFileName, 0);
			strcat(szFileName, ".BAK");
			RenameFile(SaveDialog->FileName, szFileName);
		}
		iFileHandle = FileCreate(SaveDialog->FileName);
		DATA_BLOCK *ptr = data_head;
		while( ptr != NULL )
		{
			FileWrite(iFileHandle, (char*)ptr, sizeof(DATA_BLOCK));
			ptr = ptr->next;
		}
		FileClose(iFileHandle);
	}
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::OptionsActionExecute(TObject *Sender)
{
	UpdateComBox();

    if( OptionsForm->ShowModal() == mrOk )
	{
        OptionsForm->PortBox->Text = OptionsForm->PortBox->Text.UpperCase();
        Com =  OptionsForm->PortBox->Text;
		Baudrate = StrToInt( OptionsForm->BaudrateBox->Items->Strings[OptionsForm->BaudrateBox->ItemIndex] );

		//RegistryWriteSettings();

		MainForm->Caption = APP_NAME + " - " + Com;
		Application->Title = APP_NAME + " - " + Com;
		AxisLog = OptionsForm->LogCheckBox->Checked;
		Chart->LeftAxis->Logarithmic = AxisLog;
		AxisLogBase = StrToIntDef(OptionsForm->LogBaseEdit->Text, 10);
		Chart->LeftAxis->LogarithmicBase = AxisLogBase;
	}
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::NewActionExecute(TObject *Sender)
{
	if( !dataSaved ) {
		if( Application->MessageBox(
			L"Данные не сохранены. Все равно очистить и потерять раннее сохраненные данные?",
			L"Внимание",
			MB_ICONWARNING|MB_YESNO ) == IDNO )
		{
			return;
		}
	}
	DataClearAllBlocks();
	CurrentSeries->Clear();
	data_count = 0;
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::MagnifyPlusActionExecute(TObject *Sender)
{
	double delta = (Chart->BottomAxis->Maximum - Chart->BottomAxis->Minimum) / 4;
	Chart->BottomAxis->Maximum -= delta;
	Chart->BottomAxis->Minimum += delta;
	UpdateScroll();
	ScrollBar->Position = Chart->BottomAxis->Minimum;
	UpdateActionState( state );
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::MagnifyMinusActionExecute(TObject *Sender)
{
	double max_overflow = 0, min_overflow = 0;
	double delta = (Chart->BottomAxis->Maximum - Chart->BottomAxis->Minimum) / 2;
	Chart->BottomAxis->Maximum += delta;
	Chart->BottomAxis->Minimum -= delta;
	if( Chart->BottomAxis->Maximum > data_count ) {
		max_overflow = Chart->BottomAxis->Maximum - data_count;
		Chart->BottomAxis->Maximum = data_count;
	}

	if( Chart->BottomAxis->Minimum < 0 ) {
		min_overflow = Chart->BottomAxis->Minimum;
		Chart->BottomAxis->Minimum = 0;
	}

	Chart->BottomAxis->Maximum += min_overflow;
	Chart->BottomAxis->Minimum -= max_overflow;

	if( Chart->BottomAxis->Maximum > data_count ) {
		Chart->BottomAxis->Maximum = data_count;
	}

	if( Chart->BottomAxis->Minimum < 0 ) {
		Chart->BottomAxis->Minimum = 0;
	}
	UpdateScroll();
	ScrollBar->Position = Chart->BottomAxis->Minimum;
	UpdateActionState( state );
}
//---------------------------------------------------------------------------
void __fastcall TMainForm::UpdateComBox()
{
	TRegistry *ComReg = new TRegistry;
	ComReg->RootKey = HKEY_LOCAL_MACHINE;
	ComReg->Access = KEY_READ;

	OptionsForm->PortBox->ItemIndex = -1;
	OptionsForm->PortBox->Items->Clear();

	// Com Ports
	if( ComReg->OpenKey("\\HARDWARE\\DEVICEMAP\\SERIALCOMM\\", false) )
	{
		DWORD count = 0;
		DWORD result = RegQueryInfoKey(ComReg->CurrentKey, NULL, NULL, NULL, NULL, NULL, NULL, &count, NULL, NULL, NULL, NULL);
		if ((result == ERROR_SUCCESS)&&(count > 0))
		{
			DWORD name_len;
			DWORD value_len;
			wchar_t name[128];
			wchar_t value[128];
			BYTE comport_numbers_list[256];
			int comport_nums_count = 0;

			for (DWORD i=0; i<count; i++)
			{
				value_len=128;
				name_len=128;

				result = RegEnumValue( ComReg->CurrentKey, i, name, &name_len, 0,0, (BYTE *) value, &value_len);

				if (result!=ERROR_SUCCESS) continue;

				char *stopstring;
				int iComNum;

				//
				iComNum = _wtoi( &value[3]);


				//if( stopstring[0] == '\0' )
				{
				  for( int j = 0; j < comport_nums_count; j++ )
					  if( iComNum == comport_numbers_list[j] )
						  continue;

					comport_numbers_list[comport_nums_count] = iComNum;
					comport_nums_count++;
				}
			}
			while( comport_nums_count )
			{
				int min = 0;

				for( int j = 1; j < comport_nums_count; j++ )
				{
					if( comport_numbers_list[j] < comport_numbers_list[min] )
					{
						min = j;
					}
				}

				UnicodeString usNewPort = "COM"+IntToStr(comport_numbers_list[min]);

				OptionsForm->PortBox->Items->Add( usNewPort );

				if( OptionsForm->PortBox->ItemIndex == -1 ||
					OptionsForm->PortBox->Items->Strings[OptionsForm->PortBox->Items->Count-1] == Com )
				{
					OptionsForm->PortBox->ItemIndex = OptionsForm->PortBox->Items->Count-1;
				}

				comport_numbers_list[min] = comport_numbers_list[comport_nums_count-1];

				comport_nums_count--;
			}

			if( OptionsForm->PortBox->ItemIndex == -1 &&
				OptionsForm->PortBox->Items->Count > 0 )
			{
				OptionsForm->PortBox->ItemIndex = 0;
			}
		}
	}
	ComReg->CloseKey();
	delete ComReg;
}

int margin_left = 56;
int margin_right = 52;
int margin_top = 15;
int margin_bottom = 40;
bool value_hinted = false;
void __fastcall TMainForm::ChartMouseMove(TObject *Sender, TShiftState Shift, int X,
          int Y)
{
//	if( data_count == 0 ) return;
//	double XVal, YVal, valy, valy2;
//	int SXVal, SYVal;
//	UnicodeString str;
//	if( X < 0 || Y < 0 ) return;
//	CurrentSeries->GetCursorValues( XVal, YVal );
//	SXVal = Chart->Walls->Back->Width;
//	SXVal = (int)((XVal>=0)?(XVal+0.5):-1);
//	SYVal = (int)((YVal>=0)?(YVal+0.5):-1);
//
//	if( SXVal >= Chart->BottomAxis->Minimum && SXVal <= Chart->BottomAxis->Maximum &&
//		 SYVal >= Chart->LeftAxis->Minimum && SYVal <= Chart->LeftAxis->Maximum )
//	{
//		value_hinted = true;
//		valy = CurrentSeries->YValues->Value[SXVal];
//		str = CurrentSeries->Labels->Labels[SXVal];
//		Chart->Repaint();
//
//		int dx, dy;
//		if( SXVal > ((Chart->BottomAxis->Maximum+Chart->BottomAxis->Minimum)/2) )
//			dx = -160;
//		else
//			dx = 10;
//		if( SYVal < ((Chart->LeftAxis->Maximum+Chart->LeftAxis->Minimum)/2) )
//			dy = -60;
//		else
//			dy = 10;
//
//		int x_size = Chart->Width;
//		int y_size = Chart->Height;
//
//		Chart->Canvas->Pen->Color = clBlack;
//		Chart->Canvas->MoveTo( margin_left, Y );
//		Chart->Canvas->LineTo( x_size-margin_right, Y );
//		Chart->Canvas->MoveTo( X, margin_top );
//		Chart->Canvas->LineTo( X, y_size-margin_bottom );
//
//		Chart->Canvas->Brush->Color = clWhite;
//		Chart->Canvas->Rectangle(X+dx,Y+dy,X+dx+150,Y+dy+50);
//
//
//		Chart->Canvas->TextOutW(X+dx+10,Y+dy+5,L"Время: "+str);
//		Chart->Canvas->TextOutW(X+dx+10,Y+dy+17,L"Ток: "+FormatFloat("#", valy)+L" A");
//		Chart->Canvas->TextOutW(X+dx+10,Y+dy+29,L"Сопротивление: "+FormatFloat("#", valy2)+L" Ом");
//	} else {
//		value_hinted = false;
//		Chart->Repaint();
//	}
}
//---------------------------------------------------------------------------


void __fastcall TMainForm::ChartMouseWheelDown(TObject *Sender, TShiftState Shift,
		  TPoint &MousePos, bool &Handled)
{
//	double delta = 10;
//
//	int x_size = Chart->Width;
//	int y_size = Chart->Height;
//
//	TRect rect;
//	rect.Left = margin_left-delta;
//	rect.Right = x_size-margin_right+delta;
//	rect.Top = margin_top;
//	rect.Bottom = y_size-margin_bottom;
//
//	if( (rect.Right) <= (rect.Left) ) {
//		return;
//	}
//	Chart->ZoomRect(rect);
//
//	if( Chart->BottomAxis->Minimum < 0 )
//		Chart->BottomAxis->Minimum = 0;
//
//
//	if( Chart->BottomAxis->Maximum > data_count )
//		Chart->BottomAxis->Maximum = data_count;
//
//	if( (Chart->BottomAxis->Maximum-Chart->BottomAxis->Minimum) > ((Chart->Width-margin_left-margin_right)/3) )
//	{
//		Chart->BottomAxis->Maximum = Chart->BottomAxis->Minimum + (Chart->Width-margin_left-margin_right)/3;
//	}
//
//	UpdateScroll();
//	ScrollBar->Position = Chart->BottomAxis->Minimum;
//	UpdateActionState( state );
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::ChartMouseWheelUp(TObject *Sender, TShiftState Shift, TPoint &MousePos,
		  bool &Handled)
{
//	double delta = 10;
//
//	int x_size = Chart->Width;
//	int y_size = Chart->Height;
//
//	TRect rect;
//	rect.Left = margin_left+delta;
//	rect.Right = x_size-margin_right-delta;
//	rect.Top = margin_top;
//	rect.Bottom = y_size-margin_bottom;
//
//	if( (rect.Right) <= (rect.Left) ) {
//		return;
//	}
//	Chart->ZoomRect(rect);
//
//	UpdateScroll();
//	ScrollBar->Position = Chart->BottomAxis->Minimum;
//	UpdateActionState( state );
}
//---------------------------------------------------------------------------

